[ { "title": "Liquid Exception: undefined method gsub for 502:Integer in", "url": "/posts/github_blog_issue/", "categories": "웹, 개발 고민", "tags": "Integer, error, github, blog, action", "date": "2023-11-13 22:00:00 +0900", "snippet": "어느날 확인해본 결과 알게된 오류오랜만에 커밋해두었던 블로그의 내용을 저장소에 푸쉬하였는데, 반영이 되지 않아서 캐시 문제라고 생각했었다.그런데, 충분한 시간을 기다리고 캐시 사용을 중지하거나 강제로 새로고침하여도 반영되지 않아서 깃허브 action에서 빌드등의 오류가 생겼다 싶어서 확인하러 갔다.아니나 다를까, 역시 깃허브 action에서 오류가 있었음을 확인할 수 있었는데, 저번 달에 푸쉬한 내역도 오류가 있었다.확인을 안하고 넘어간 탓에 모르고 있었던 것이다.그렇게 오류 내역을 찬찬히 살펴보는데,Liquid Exception: undefined method gsub' for 502:Integer in /home/runner/work/yongheonn.github.io/yongheonn.github.io/_layouts/post.html앞선 내용의 에러를 확인할 수 있었다.처음엔 그냥 생각없이 대충 말그대로 _layout 폴더의 post.html부터 찾아가 에러를 고치려 했다.그런데, 생각해보면, 해당 파일은 블로그 시작부터 수정한 적이 없어서 왠만해선 원인이 아닐 것이라는 점을 알 수 있다.실제로 약간 의심이 가는 부분이 있어 수정해보아도 전혀 원인이 아니었다.그렇게 커밋 내역을 살펴보고, 다시 에러 메세지를 제대로 살펴보니 원인을 짐작할 수 있었다._layout 폴더의 post.html은 말그대로 블로그 포스트의 레이아웃을 설정해둔 것으로, 실제 포스트에서 뭔가 문법적으로 오류가 있었다는 뜻을 내포할 수도 있으며, 502:Integer에서 숫자와 관련된 무언가의 문제가 있다는 뜻을 추측할 수 있었다.실제로 커밋 당시 2023-10-07-cors-issue 포스팅 내부를 보면, 태그에서 502, 504를 그대로 썼는데, 이게 따옴표로 감싸주지 않으면 에러가 발생하는 것이었다.그렇게 해당 숫자를 따옴표로 감싸주니 바로 에러가 해결되어 포스팅 반영이 제대로 되었다." }, { "title": "갑작스러운 504 및 502 cors 에러", "url": "/posts/cors_issue/", "categories": "웹, 개발 고민", "tags": "cors, 502, 504, origin, aws, cloudflare", "date": "2023-10-07 18:00:00 +0900", "snippet": "어느날 갑자기 api 통신이 안되는 오류 발생주기적으로 yongheonn.com 사이트를 점검하던 어는 날, 아무것도 건드린 적 없는데, 잘되던 사이트에 문제가 발생했다.프론트 단의 사이트 자체는 문제가 없었으나 백엔드와의 통신이 먹통이 되었는지, 게시판 목록을 받지 못하고 있던 것이다.그래서, 일단 개발자 도구를 통해 네트워크 탭을 확인했고, 504 에러를 확인했다.그리고, 콘솔을 확인한 결과yongheonn.com/:1 Access to fetch at 'https://api.yongheonn.com/ajax/subject/all' from origin 'https://yongheonn.com' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.라는 에러 결과를 확인할 수 있었고, 당연스럽게 cors 설정부터 살펴봤으나, 이상이 없었고, 잘 생각해보면 코드를 건드린 적이 없는데, 코드 관련 이슈일 리는 없다는 판단을 내렸다.그렇기에 aws ec2부터 확인했고, 잘 실행중이었으나, 혹시 몰라 재부팅 후, 프로세스도 다시 실행해주었다.그러더니 504 에러 대신 502 에러가 뜨기 시작했고, 프로세스가 어쩌다보니 죽어있었다는 판단을 내렸다.하지만 여전히 에러가 뜨는 것은 여전했고, ssh 연결을 통해 내부에서 curl 명령어로 확인해본 결과, 내부 8080 포트는 연결이 잘 되고 있었고, 밖에서도 http://ec2-43-200-79-234.ap-northeast-2.compute.amazonaws.com:8080/ajax/subject/all 로 curl을 던져보니 결과를 잘 받아왔다.그렇기에 loadbalancing 부분이나 cloudflare 부분에서 뭔가 잘못되었다는 결론을 내렸다.그리고, 실제로 로드밸런싱의 http://yongheonn-loadbalancer-262576260.ap-northeast-2.elb.amazonaws.com:8080 로 curl을 실행해보니 긴 시간후 connection failed를 응답했다.curl로 http://yongheonn-loadbalancer-262576260.ap-northeast-2.elb.amazonaws.com:8080가 아닌 https://yongheonn-loadbalancer-262576260.ap-northeast-2.elb.amazonaws.com 로 줬을때, 반응이 생겼었다.하지만 올바른 인증서가 아니라 하여 인증서 문제인줄 알고, acm 인증서를 확인하니 만료되어 있어, acm 인증서 발급을 요청하여 새로 발급하고, 이를 로드밸런싱에 연결한 다음, cloudflare에 dns로 등록해주었다.하지만, 이래도 이상한 반응을 보였는데, curl을 통한 ssl 인증서 관련 오류는 무시해도 좋다는 글들을 읽을 수 있었고, 다시 -k 옵션을 주니 502 에러가 떴다.즉, 로드밸런싱 문제는 확실하다는 것으로 인증서 문제는 아니었던 것이다.aws loadbalancing 탭에서 대상 그룹으로 전달 부분을 따라가보니 등록된 대상의 상태 확인에 unhealthy라는 문제를 발견할 수 있었다.인터넷에서 관련 정보를 찾아본 결과, loadbalancer는 기본 주소, 즉 “/”로 health check를 실행한다고 한다.즉, 서버가 건강한지 주기적으로 기본 주소로 체크를 하는데, 내 백엔드 프로젝트에서는 api 역할만 신경쓰고, 기본 주소로 들어오는 요청에 대한 로직을 설정해두지 않았기 때문에, 건강하지 못한 서버로 판단되고, 요청을 거절하고 있었던 것이다.그렇기에 사용 몇달간은 문제가 없었지만, 어느 시점, health check가 실행된 이후 api 통신에 문제가 생겼던 것이다.사실, 30초 주기로 체크하는데, 이 옵션이 이제 와서 어쩌다 켜진건지, 혹은 원래 켜져있었는데, 어떻게 문제가 발생하지 않았는지는 의문이다.어찌되었건, /ajax/health/ 로 health check를 받도록 loadbalancing 옵션을 적절히 설정해주었고, 스프링 시큐리티에서도 해당 주소는 인증없이 접근 가능하도록 설정을 바꾸어주었다.문제는 이런데도 계속 unhealthy가 떴고, 여러 시도 끝에 health check 포트를 8080으로 지정하면 healthy로 뜨는 것을 확인했다.해당 대상은 알고보니 80포트를 대상으로 했을 때, 문제였던 것이고, 따로 8080포트를 대상으로 그룹을 열어줘야 되었던 것이다.이에 따라, 8080포트로 대상 그룹에 새로 인스턴스를 연결해주니 해당 포트는 healty로 뜨고, 사이트도 정상 작동하였다." }, { "title": "github 민감한 정보 관리", "url": "/posts/submodule/", "categories": "웹, 개발 고민", "tags": "git, private, submodule, yml, properties", "date": "2023-05-04 07:00:00 +0900", "snippet": "git에서 민감한 정보 처리spring에서 application.yml이나 application.properties등 민감한 정보를 관리할 때, .gitignore를 통해서 공개되지 않도록 한다.로컬 개발 환경에서는 문제되지 않지만, 문제는 실제 프로덕션에 전달할 때이다.이러한 때에는, submodule을 사용하면 좋다.secret key를 활용할 수도 있으나 너무 제한적이고, application.yml이나 application.properties와 같은 파일 형식에 적용하기는 힘들다.submodule을 사용하면 권한있는 사용자만 볼 수 있으며, github action에서도 해당 파일을 활용할 수 있으니 편리했다.대신, 해당 push 내역을 반영하려면 git submodule update --remote을 활용하면 좋다." }, { "title": "aws data transfer 트래픽 문제(폰트)", "url": "/posts/font-traffic/", "categories": "웹, 개발 고민", "tags": "font, ttf, traffic, aws, data-transfer", "date": "2023-04-12 02:00:00 +0900", "snippet": "aws data transfer 트래픽 이상불과 하루도 안되어 프리티어 공짜 한도인 1gb 중 거의 700mb를 사용했다.처음엔 해킹도 의심했지만 그렇다기엔 이상한 점이 한둘이 아니라, 이 트래픽을 추적하다보니 ttf 파일이 혼자 600mmb 정도 차지하고 있었다.ttf 파일은 리액트 프로젝트 생성시 자동으로 assets/font에 들어가 있었고, 정확히 이 폴더 내 용량 합이었다.이 용량이 무려 13mb라 굉장히 트래픽에 부담되는 현상이 일어난 것이다.이 때문에 웹사이트 로드도 굉장히 느려졌었고, 어떻게든 해결해야겠다고 생각했다.처음엔 cdn을 활용해서 폰트를 서비스할까 생각했지만, 이 역시 전보단 훨씬 낫겠지만 지연이 발생하고, 앞으로 남은 한도를 생각하면 더 트래픽을 아낄 필요성이 느껴졌다.그래서 woff 형식의 압축으로 직접 제공할까 생각했지만 이 역시 한글 폰트를 제공하기에 너무 용량이 컸다.subset을 활용할 생각도 했지만, 게시판 특성상 자주 않쓰는 한글 글자도 활용될 확률이 높아 만에 하나 그런 상황이 발생할 것을 상상하면 한 문장 내에 폰트가 서로 다른 현상은 반갑지 않았다.그렇기에 트래픽은 하나도 발생하지 않는 src: local로 font-face를 설정하고, 최대한 사용자 로컬 환경에서 폰트를 활용하기로 했다.사실 로컬에만 의존하는 것은 사용자 환경에 따라 굉장히 서비스가 달라질 환경이 있어 실제 서비스에선 보조적으로 활용하는 것이 좋아보였지만, 일단 이번달은 남은 무료 트래픽도 거의 없고 해서, 최대한 아끼기로 했다.다음 달엔 local과 woff2를 활용해서 폰트를 제공하지 않을까 싶다.그리고, 여기서 더 아끼기 위해 캐시 설정을 하기로 했고, 그것은 따로 다른 포스팅에서 다뤄놓았다." }, { "title": "aws s3 정적 사이트 캐시 문제", "url": "/posts/cache_setting/", "categories": "웹, 개발 고민", "tags": "aws, s3, lambda, nodejs, cache, metadata", "date": "2023-04-12 02:00:00 +0900", "snippet": "html, css, js 캐시 문제 해결기본적으로 리액트 빌드시 index.html은 그대로지만, static 폴더의 css와 js는 매번 파일명이 변경되어 새로 업로드된다.여기에 어차피 html에서 로드할 css와 js가 결정되기에 css와 js의 캐시를 최대한 길게 잡아도 업데이트할 때는 새로운 css와 js가 적용되며, 업데이트되지 않았을 때 계속 캐시를 사용하는 최적화가 일어난다.반면 index.html은 파일이름이 그대로여야 하기에 캐시를 길게 적용하기에 문제가 있다.그렇기에 html에는 cache-control: private, no-cache로 css와 js는 cache-control: public, max-age: 31536000로 설정해주면 캐시 최적화가 더 잘된다.나는 aws s3와 cloudfront를 이용해서 정적 사이트 배포를 하고 있었기에 s3에서 각 파일의 metadata를 수정해줘야했다.문제는 한번 metadata를 직접 수정해놔도 새로운 파일이 업로드되거나 교체되먼 기존 meatadata는 사라지기에 배포 때마다 자동으로 metadata를 수정하게 해야했다.aws lambda위 문제는 aws lambda를 이용해서 해결했다. aws lambda에서 s3 대상으로 생성 이벤트와 접두사 static/과 index.html일 때의 두개의 트리거를 생성했다.// 추후 favicon.ico logo???.png img 폴더 등의 이미지도 자주 변경되지 않을 것으로 예상되기에 트리거 대상에 포함하고, 1주일 정도의 캐시를 적용했다.여기서 나는 nodejs 18을 이용해서 코드를 작성했고, 몇번의 시행착오 끝에 결국 자동화를 해냈다.여기서 주의점은 nodejs 18은 이전 버젼과 달리 s3client를 import해야 했다.그리고, getobject 후 다시 copyobject로 업데이트할 때, copyobject로 인한 생성 이벤트로 다시 무한히 반복되는 것을 방지하기 위해, 생성 이벤트로 들어왔을 때, cache-control이 undefined인지 확인하고, undefined일 때만 copyobject를 실행하고, 아니면 실행하지 않도록 했다." }, { "title": "스프링 부트에서 daum 메일 전송 주의점", "url": "/posts/spring_mail_error/", "categories": "웹, 개발 고민", "tags": "spring-boot, java, smtp, mail, daum", "date": "2023-04-09 03:07:00 +0900", "snippet": "주의점다음 메일은 smtp에서 ssl 방식을 사용하기에 포트는 465로 하고, properties에서 ssl을 따로 enable: true로 해주어야 한다.그리고, 계속 452 check your e-mail address라는 에러가 떠서 확인해 봤더니, application.yml 문제인줄 알았는데 SimpleMailMessage에서 setFrom을 안해서 생긴 문제였다.이는 본격적으로 배포 전에 구글 메일을 다음 스마트워크 서비스로 바꾸어 인증 메일을 직접 도메인 메일을 통해서 구현하려고 했기 때문이었다.구글과 달리 다음은 from을 따로 설정해주지 않으면 에러가 생기는 것이었다." }, { "title": "게시판 계획", "url": "/posts/notice_board_plan/", "categories": "웹, 개발 고민", "tags": "notice-board, plan", "date": "2023-03-13 10:17:00 +0900", "snippet": "앞으로 할 것Front-end flux 패턴 공부, redux 도입 고민 글작성 div contenteditable 속성 이용해서 구현 (해결) 글 수정 및 삭제 기능 구현 (해결) 댓글 기능 구현 댓글 기능 및 이미지 등에 lazy loading 이용 /** */ 주석을 이용한 코드 설명 import 문법이나 react.lazy를 이용한 코드 분할 서버와의 비동기 처리에서 react-query 이용 경우에 따른 tdd 개발 방식 적용Back-end 데이터베이스 테이블 정규화 점검 주석 활용 댓글 관련 db, 서비스 구현 board나 subject 작성 내용에서 image나 video 태그 들어왔을 때, 크기 조절 속성 등 자동으로 삽입 OAuth 2.0 Login 지원 (해결) 기존 system.out.println 대신 log를 활용하여 기록하기Dev-ops 클라우드 서버를 이용한 배포 (해결) github action을 이용한 자동 배포 (해결)" }, { "title": "게시판 비밀글 개발중에", "url": "/posts/board-secret/", "categories": "웹, 개발 고민", "tags": "secret, pw, key-input, mobile, public-scope", "date": "2023-03-06 17:30:00 +0900", "snippet": "비밀번호 입력방식처음에 글에 비밀번호를 설정할 수 있게 하여, 비밀번호를 설정할 시, 글쓴이, 운영자, 비밀번호를 아는 사용자만 볼 수 있게 하는 구조를 만들었었다.그리고, 이를 위해 비밀글로 접근시 글쓴이, 운영자가 아닐 경우 비밀번호 입력 화면으로 이동하게 만들었는데, 보통 유명 사이트들에서 인증코드 입력 화면을 참고하여 6자리 코드를 영문 및 숫자로만 입력할 수 있게 만들었다.이때, 각 6자리에 한글이나 특수문자가 입력되지 않게 해야했는데, 문제는 onchange나 oninput 이벤트에서 한글이나 특수문자를 걸러도, 화면에선 잠깐 나왔다가 사라지는 형식으로 사용자에게 있어서 불편함을 일으킬 수 있다고 판단했다.그래서, 각 6자리를 div로 글자만 출력하게 하였고, 따로 input을 보이지 않게 만들고, 동적으로 매번 포커스가 가게 만들었다.그리고, 데스크톱 환경에선 훌륭하게 성공하였으나, 문제는 모바일이었다. 먼저, 이 방식에선 input이 readonly이고, 보이지 않아서인지 포커스를 주어도 모바일에선 가상키보드가 나타나지 않았다.그리고, 2번째 문제는 oninput 이벤트에서 처음엔 keycode 속성을 이용해 아스키코드 값으로 분류하였는데, input에서 readonly를 없애고 모바일에서 입력해보아도 숫자와 영문자 모두 229 값이 나왔다.백스페이스나 엔터 값등은 특정 조건 하에서 제대로 나왔지만, 숫자와 영문자가 특히 문제였다.그래서, keycode가 더 이상 추천되는 방식이 아님을 알고, key 속성으로 분류하려고 시도하였으나, 역시 숫자나 영문자가 undefined로 나왔다.이 문제는 모바일 imei 쪽에 따른 것이기에 key 입력 방식으로는 불가능하다고 판단하고, 방식을 바꾸기로 했다.다음 생각한 것은 oninput에서 onchange 이벤트를 통해 들어오는 문자열 마지막 문자를 기준으로 판단하기는 것은 어떤가 생각해봤다.2번째 문제는 해결하더라도 결국 input이 readonly로 숨겨놓으면, 가상키보드가 뜨지 않아서 골치 아픈 것은 마찬가지였다.이때, 생각해서 해결한 것이 width와 height를 0px로 하고, 커서를 없애면 결국 안보이는 건 똑같지 않은가였고, 이덕분에 해결하였다.결론생각해보면 비밀글 방식 자체보단 공개범위를 통한 것이 더 많이 쓰이고, 좋다는 생각이 들었다.실제로 페이스북이나 인스타 같은 유명 사이트에선 글을 공개범위로 제어하는 모습을 볼 수 있었다.그래도 비밀번호 방식 자체의 유용성이 아예 없는 것은 아니기에 혼용해서 쓰는 것으로 결론을 내렸다.-수정width와 height를 0px로 하면 모바일에서 input값이 역순으로 나오는 것이 확인되었다.심지어 1234a와 같이 입력하면 출력이 1234a4321 같이 역순뿐 아니라 이상하게 나왔다.이때, direction, unicode-bidi 등 여러 속성을 건들여봐도 계속 이상하게 출력되었기에 width와 height를 1px로 하고 color만 transparent로 투명하게 만들어봤더니 이제 정상적으로 출력이 되었다." }, { "title": "Mysql index vs multi tables", "url": "/posts/db_thinking_2/", "categories": "웹, 개발 고민", "tags": "mysql, db, index, multi, optimizing, page, sort", "date": "2022-11-10 12:30:00 +0900", "snippet": "멀티 인덱스 최적화게시판 주제로 프로젝트를 짤때, 주제별로(ex: 자유게시판, 질문게시판등으로 나눌때, 혹은 주제별로 카테고리를 나눌때) 게시판을 분류한다고 가정한다.이때, 게시판을 페이지를 기준으로 리스트를 뽑아온다면, subject(주제)와 그에 해당하는 게시판 번호(s_bno)를 인덱스로 설정하면 좋을 것이다.이 두 컬럼은 같이 쓰기 좋기에 다중 컬럼 인덱스로 설정할텐데 여기서 궁금점이 생겼다.누군가는 다중 컬럼 인덱스는 카디널리티가 높은 순으로 설정하는 것이 빠르다고 말하고 있지만 내가 아는 mysql의 b tree 형식을 생각해보면 앞과 같이 페이지로 게시판 리스트를 뽑아온다면 달라질 것 같았기 때문이다.실제로 일반적으로 알려진대로라면 s_bno를 앞에 둬야 더 검색이 빠를 것 같지만, 결과는 그 반대였다.이는 아마 b tree 형식은 미리 정렬된 인덱스를 값을 비교해 leaf까지 도달해서 값이 더 크면 오른쪽으로 점차 탐색하고 아니면 왼쪽으로 탐색하는 구조 때문일 것 같았다.수직 탐색에서는 카디널리티가 높은 s_bno가 앞선 쪽이 유리하지만, 수평 탐색에서는 카디널리티가 낮은 subject가 앞선 쪽이 유리할 것이기 때문이다.실제로 subject 100개, s_bno 2000개인 테이블을 인덱스 순서를 달리해 explain 구문을 통해 분석했을 때, filterd 항목, 즉 수직 탐색에서 걸러진 비율은 1: 10으로 10배 정도 차이 났지만, 탐색 rows에서 57578 : 301 정도로 수평 탐색에서 꽤 큰 차이를 보인 걸로 예상된다.일반적으로 flitered * rows의 수치가 낮을 수록 좋으므로, 실제로 거의 10배 이상 성능 차이가 났다. 물론 filtered와 rows가 추정된 계산값이라고는 하지만 이정도 차이와 시간 차이는 나름 유의미해보인다.그리고, 여기서 추가로 알 수 있었던 점은 수평 탐색시 앞선 컬럼의 값을 기준으로 먼저 탐색하다가 그 값에 다다르면 그때 후자의 값으로 탐색하는 것 같다. explain의 rows 항목을 보면 57508의 값은 2000 * 30과 근사한 값이다.limit 30으로 30개의 게시판을 뽑아왔을 때의 값이므로, s_bno를 앞서게 했을 때, 수직 탐색에서 바로 s_bno 값을 찾았더라도, 다음 1개를 찾으려면 s_bno 값을 전부 탐색해야 하기 때문이다.그리고, 조건문이 둘다 등호인 경우는 성능 차이가 없다고 봐도 되었다.즉, 등호만 사용하는 단일 검색은 순서가 상관없고, 부등호가 사용될 때 부등호를 사용하는 조건의 인덱스를 뒤에 두는 것이 더 빨랐다.즉, 멀티 컬럼 인덱스의 순서는 카디널리티는 거의 상관없고, 조건문에서 컬럼이 등호에 쓰이는지 부등호에 쓰이는지에 따라 순서를 달리 해야한다는 것을 알게됐다.생각보다 차이가 유의미했다는 점을 생각하면만약 페이지를 통해 게시물을 나누고, 페이지 번호를 통해 게시물을 일정 갯수 보여준다면,기본적으로 select from ? where subject=#{subject} order by bno limit ? ?의 형태거나 select from ? where subject=#{subject} and bno &gt;= ? order by bno limit ?일 것이다.후자가 더 일반적으로 효율적이다. 그리고, 문제는 bno를 전체 게시판 기준일지 주제별로 따로 나눌지의 문제인데" }, { "title": "Mysql index vs multi tables", "url": "/posts/db_thinking_1/", "categories": "웹, 개발 고민", "tags": "mysql, db, index, table, multi", "date": "2022-11-10 12:30:00 +0900", "snippet": "하나의 테이블과 인덱스 vs 여러개의 테이블결론hash 파티셔닝 사용여러개의 테이블은 성능 저하인덱스의 적절한 사용은 테이블 분리보다 성능이 좋다.생각해보면 테이블 분리는 테이블 검색 비용 증가로 모든 테이블 성능이 나빠진다.서버를 증설해서 서로 다른 서버에 테이블을 분리시킬 것이 아니면 하나의 테이블에서 인덱스 사용이 좋아보인다." }, { "title": "Git 비밀번호 재설정", "url": "/posts/git_pw_update/", "categories": "웹, 개발 고민", "tags": "pw, password, git, token, update", "date": "2022-11-01 17:30:00 +0900", "snippet": "Git 비밀번호 재설정 방법최근 github는 사용자 비밀번호가 아닌 토큰을 이용하여 push 접근 등을 허용한다.그리고, window 자격 증명 관리자 등 여러 방법을 사용해봤으나 계속remote: Invalid username or password. fatal: Authentication failed for '&lt;깃허브주소&gt;'같은 메시지가 떴고, 잘 생각해보다 .git 디렉토리에 있는 config 파일을 수정해주면 된다는 것을 깨달았다.깃 프로젝트 최상단에 있는 .git 폴더 내부에 config 파일이 있는데 그 내용은 다음과 같다.중간에 비어진 저부분에 ghp_로 시작하는 토큰값을 갱신해주면 비밀번호 재설정이 완료된다." }, { "title": "이메일 인증 방법", "url": "/posts/email_authentication/", "categories": "웹, 개발 고민", "tags": "email, authentication, code, link", "date": "2022-09-20 03:30:00 +0900", "snippet": "인증 방식 차이이메일 인증은 코드를 발송하여 사용자가 코드를 입력하게 하거나,링크를 발송하여, 링크에 들어가게 하는 두 가지 방법이 주로 사용된다.먼저 코드를 입력하는 방법은 링크를 이용하는 방법에 비해 사용자에게 비교적 귀찮은 방법이다.아무래도 그저 링크만 들어가면 되는 방법에 비해, 코드를 보거나 복사해서 입력하는 방법은 좀 더 불편함을 야기한다.대신, 링크 방식은 로그인한 사용자의 기기가 아닌 다른 기기에서 들어갈 수 있다면, 실시간으로 인증 여부를 체크해야기 때문에, 비교적 서버의 처리가 늘어난다고 볼 수 있다." }, { "title": "JWT 토큰 인증에 대한 고민 3", "url": "/posts/jwt_thinking_3/", "categories": "웹, 개발 고민", "tags": "jwt, refresh token, access token", "date": "2022-09-12 02:30:00 +0900", "snippet": "리프레시 토큰의 저장 위치리프레시 토큰을 서버에 저장하면, 강제 로그아웃이 가능해진다. 단, 토큰을 검사해서 로그아웃 여부를 검사해야하므로, 사실상 세션 방식과 거의 동일한 부하가 걸리며, jwt 토큰만의 고유한 장점이 사라진다.이는 적절히 타협해서 재발급 시점에만 검사한다면, 즉각적인 로그아웃은 불가능해도, 서버에 부하를 줄일 수 있다.그러므로, 사실상 리프레시 토큰을 서버에 저장한다면, 두번째 방법이라고 봐야하며, 나머지는 사실상 세션 방식이라고 봐도 될 것 같다.그리고, 사실상 리프레시 토큰의 탈취를 걱정해서 서버에 저장하는 것이라면, 리프레시 토큰에 접근할 키값을 어차피 클라이언트에 저장해야하므로, 의미없다고 본다.리프레시 토큰에 중요한 정보가 들어있다는 이유라면 이해 가능하겠지만, 그것이 아니라면, 키값의 탈취로 리프레시 토큰 접근이 가능하기 때문이다.하지만, 액세스 토큰의 재발급 시점에서 리프레시 토큰에 접근할 키값을 새로 생성하고, 리프레시 토큰의 보관을 새롭게 바꾼다면, 보안상의 이점이 생길 수 있다.만약, 재발급 시점에 리프레시 토큰으로 접근할 키값을 빼앗긴다고 해도, 이미 재발급 이후에는 새롭게 키값이 설정되기에 유효하지 않아진다.물론, 응답 과정에서 새로운 키값을 가로챌 수 있다는 점에서 여전히 위험성은 있지만, 일정 시간 내에 여러번의 재발급 요청이 오면 임시 정지 조치를 하는 등의 대안책들이 생긴다.즉, 리프레시 토큰 (또는 인덱스 값) 은 클라이언트에 저장해야 한다는 것으로,로컬 스토리지나 쿠키 중에서 골라야한다는 것이다.결론적으론 쿠키가 제일 합리적인 것 같다." }, { "title": "github 블로그 작성하기 1", "url": "/posts/blog_process_write_1/", "categories": "웹, 블로그", "tags": "blog, github, jekyll", "date": "2022-08-13 16:17:00 +0900", "snippet": "이미지 첨부깃허브 블로그 이미지를 post 내에 사용하고 싶을 때, ![대체 문자열](이미지 주소)의 형식으로 이미지를 첨부하게 된다.이때, 로컬 이미지를 사용한다면 주소 끝에 ?raw=true를 붙여야 제대로 이미지가 뜬다." }, { "title": "github 블로그 개발환경 구축하기 1", "url": "/posts/blog_process_init_1/", "categories": "웹, 블로그", "tags": "blog, github, jekyll", "date": "2022-08-13 16:17:00 +0900", "snippet": "0. 개요github 블로그는 github에서 지원해주는 블로그로 가장 자유도가 높기로 유명하다.웹 관련 지식(ex. html, css, javascript 등)이 많을수록 자유롭게 커스터마이징해서 꾸밀 수 있으므로, 앞으로 웹 관련 업계에 종사할 예정이 있는 나로서는 github 블로그를 고르는 것이 옳다고 생각했다.github 블로그를 시작하려면 당연히 github 계정이 있어야하며, 백지에서부터 시작하기에는 많은 노력과 시간이 필요로하므로, 미리 어느정도 만들어진 샘플인 테마를 통해서 시작하는 것이 좋다.1. 테마 고르기내가 고른 테마 사이트는 http://jekyllthemes.org/이며, 여기서 chirpy라는 테마를 골랐다.테마를 고르면 위 사진처럼 나오게 되는데, 이때 이 테마를 적용시키는 방법은 2가지가 있다. 위 사진의 Homepage, 즉 제작자의 github 프로젝트에서 fork하는 방법 Download 항목을 통해서 다운 받거나 Homepage, 즉 제작자의 github 페이지로 이동해 code를 zip을 통해 다운받거나 release 항목의 소스코드를 다운 받는 방법기본적으로 첫번째 방법과 두번째 방법의 차이는 먼저 자신이 저장소를 만들어두었는가에 따라서 방법이 나뉜다고 봐도 된다.따로 github 블로그 저장소를 만들어두지 않았다면 첫번째, 아니라면 두번째가 편리하다.먼저 제일 간단한 fork 방식을 알아보자면 제작자의 github 프로젝트 우상단의 fork를 눌러 저장소를 복제한 다음에 복제한 저장소의 이름을 깃허브아이디.github.io 의 형태로 바꿔준다.그 다음 과정부터는 거의 동일하므로, 다음 방법을 알아보자면 먼저 Repository(저장소)를 새로 생성해주는 것부터 시작이다.만약 이미 만들어진 블로그 저장소가 있다면 다음 과정은 패스해도 된다.Repository(저장소) 생성 Repository name을 Owner(깃허브 아이디).github.io 로 하기 공개 상태를 public으로 하기나머지는 특별히 건들 것 없이 저장소를 생성한면 된다.2. 저장소 Clone이제 첫번째 방법과 두번째 방법 모두 저장소를 clone해야 하는데, 컴퓨터의 적절한 폴더에 git bash를 열거나 cmd에서 cd 명령어로 폴더 위치로 이동한 다음에 git clone [깃허브 주소].git 을 입력하면 된다.깃허브 주소는 자신의 저장소에서 code를 클릭한 다음에 clone의 https 항목에서 복사하기를 누르면 [깃허브 주소].git 이 복사된다.또는 그냥 자신의 저장소 주소를 복사하고 .git 을 붙여서 사용해도 된다.저장소 clone이 완료되면 두번째 방법의 경우 다운받았던 소스코드를 압축해제해서 로컬 git 저장소에 덮어씌운다.3. 설치해야할 것들그 다음에 첫번째 방법, 두번째 방법 모두 Ruby, RubyGems, Jekyll, Builder 을 기본적으로 설치해야 한다.Ruby는 https://rubyinstaller.org/downloads/에서 운영체제에 알맞게 설치하면 된다.다운받은 설치파일로 Ruby를 설치하면 cmd에서 git clone 저장소로 이동해야 한다." }, { "title": "JWT 토큰 인증에 대한 고민 2", "url": "/posts/jwt_thinking_2/", "categories": "웹, 개발 고민", "tags": "jwt, refresh token, access token", "date": "2022-08-13 03:30:00 +0900", "snippet": "리프레시 토큰의 필요성리프레시 토큰은 왜 필요한가?그것이 액세스 토큰과 리프레시 토큰을 알아보면서 드는 생각이었다.대표적으로 알려진 리프레시 토큰을 이용함으로써 얻을 수 있는 이점은 다음과 같다. 리프레시 토큰의 유효기간을 길게 주게 되면서, 액세스 토큰의 유효기간을 줄일 수 있어 액세스 토큰이 탈취되어도 위험성이 줄음 액세스 토큰의 유효기간을 줄여도 리프레시 토큰으로 재발급하면서 짧은 주기로 로그인할 필요가 없어짐먼저, 첫번째로 든 의문점은 왜 리프레시 토큰이 더 안전하게 뺏길 일이 없는가였다.리프레시 토큰을 안전하게 보관할 수 있다면, 그것은 액세스 토큰도 가능할 것이다.둘은 사실상 같은 토큰이고, 안에 담고 있는 내용만 다를 뿐이다.그렇기에 왠만해선 한쪽이 뺏기면 나머지도 자연스럽게 뺏기기 쉽다고 생각했고, 이러면 굳이 재발급을 해가면서 더 서버의 자원을 소모시켜야는가 싶었다.리프레시 토큰도 뺏기면 결국 리프레시 토큰의 유효기간만큼 해커한테 넘어가는 것은 똑같기 때문이다.두번째 의문은 리프레시 토큰을 사용하면 짧은 주기로 로그인할 필요가 없다는 점이다.두번째는 재발급의 자동화가 가능하다는 것인데, 이는 사실 액세스 토큰만으로도 구현이 가능하다.액세스 토큰의 재발급이 필요한 시점에 액세스 토큰의 유효성을 체크하고, 새로 발급만 해주면, 사실 다를 바가 없다.여기서 잘 생각해보고, 더 정보를 모아보니 첫번째 의문은 해결할 수 있었다.먼저, 첫번재는 액세스 토큰과 리프레시 토큰의 노출 빈도에 정답이 있었다.기본적으로 액세스 토큰은 서버에 요청을 보낼 때, 대부분 사용을 하게 된다. 반면, 리프레시 토큰은 오직 재발급 시점에만 사용이 된다.오직 하나의 토큰만으로 재발급 여부를 결정한다면, 어떤 요청 시점에서 탈취된 토큰으로 재발급이 가능하다.반면, 토큰을 둘로 나누어, 검증 과정에 리프레시 토큰과 액세스 토큰을 모두 필요로 한다면 어떤 요청 시점에 탈취된 액세스 토큰만으로는 검증이 불가능하며, 클라이언트가 재발급하는 시점에 네트워크로 리프레시 토큰을 탈취해야 재발급이 가능해진다는 것이다.즉, 리프레시 토큰의 사용은 적어도 네트워크에서의 보안 강화로 이어지는 것이다.쿠키를 서버에서 지정하여 httponly 등 보안 강화를 하면 브라우저에서 request 시에 자동으로 전송된다는 점 때문에 순간 다시 의문이 들었으나, 이는 쿠키의 path 설정을 간과한 문제여서 큰 문제는 아니었다.애초에 쿠키 자체가 request 시에 자동으로 서버로 전송되나, httponly 옵션을 주면 자바스크립트 단계에서 접근이 불가능하여, xss 공격에 내성이 생기는 것이다.로컬스토리지의 경우 xss 공격에 더 취약한 편이니, 이런 점에서 서버 측에서 httponly 옵션과 path를 사용하여 특정 링크(재발급)로만 쿠키가 전송되도록 하는 것이 제일 안전한 방법인 것이다.물론 서버 메모리나 db에 저장하면 더 안전하겠지만, 그 순간 이미 세션의 개념으로 취급해야 한다고 봐야기 때문에, jwt 토큰 방식만의 장점을 취하면서 제일 안전한 것은 옵션을 적절하게 설정해놓은 쿠키라고 볼 수 있을 것이다.또한, 위에서 다루진 않았지만 리프레시 토큰의 사용은 액세스 토큰의 보안 강화로 이어질 수 있다.리프레시 토큰을 사용한다면, 액세스 토큰을 로컬 변수에 저장할 수 있게 된다.기존에 토큰 하나로 모든 걸 처리하려 할 때, 토큰을 로컬 변수에 저장한다면, 새로고침했을 때, 토큰이 사라져, 로그인을 유지할 수 없게 된다.하지만, 리프레시 토큰을 사용하면, 액세스 토큰을 재발급 받게 하여, 로그인을 유지시킬 수 있고, 이에따라 xss 공격과 csrf 공격에 좀 더 안전해질 수 있다.로컬 변수의 경우 xss 공격과 csrf 공격으로 탈취하기가 더 어렵기 때문이다.물론, 이 경우는 새로고침할 때마다 서버에 부하가 많이 가는 점을 고려해야 한다.리프레시 토큰에 이 이상의 장점이 있을 수도 있겠으나, 아직 내가 알 수 있는 것은 이 정도뿐인 것 같다." }, { "title": "JWT 토큰 인증에 대한 고민", "url": "/posts/jwt_thinking/", "categories": "웹, 개발 고민", "tags": "jwt, refresh token, access token", "date": "2022-08-13 03:30:00 +0900", "snippet": "jwt vs 세션" }, { "title": "블로그 시작하기", "url": "/posts/start_blog/", "categories": "개발 일기", "tags": "getting started", "date": "2022-08-13 03:18:00 +0900", "snippet": "블로그 시작 계기어느 때와 같이 게시판 프로젝트를 진행하던 중에 코로나 대유행을 피하지 못하고, 결국 나도 코로나에 처음으로 걸리게 되었다.생각보다 심하게 걸려서 1~2주는 꼼짝도 못했는데, 어느정도 컨디션을 회복하고 나서, 다시 프로젝트를 진행하고자 했다.당연히 고작 1~2주였기에 프로젝트 진행에 큰 문제는 없었으나, 2%정도 무언가 부족한 느낌이 든다는 찝찝함과 함께 고민에 빠졌다.그것이 내가 전에 프로젝트를 진행할 때 했던 고민들, 그리고 스택오버플로우나 여타 커뮤니티들을 돌아다니며 얻었던 지식들 때문이라는 것은 금방 깨달을 수 있었다.고민이나 일부 지식들은 단순 주석이나 깃허브의 readme에 적기엔 적합하지 않다고 생각했고, 그냥 머리속에 기억해두거나 대충 메모장에 저장해 바탕화면에 저장해두었다.게다가 도저히 기억 안나는 지식들은 다시 검색의 힘을 빌리면 금새 찾을 수 있었기에 굳이 내가 블로그로 정리할 필요성은 느끼지 못했다.하지만, 내가 했던 나만의 고민은 검색으로 찾지 못하는 것이었고, 그 고민의 상세한 흐름은 일일히 전부 기억에 담아두기란 불가능에 가까웠다.향후 계획일단 게시판 프로젝트의 진행 및 플래너 프로젝트의 계획 등의 과정과 그에 따른 고민들을 블로그에 정리해나가는 것부터 시작하기로 했다." } ]
